pub mod problem {
    use sea_orm::{entity::prelude::*, FromQueryResult, DerivePartialModel};
    use serde::{Deserialize, Serialize};
    use crate::{contest, education, submit, testcase, user};
    #[sea_orm(table_name = "problem")]
    pub struct Model {
        #[sea_orm(primary_key, auto_increment = true)]
        pub id: i32,
        pub user_id: i32,
        pub contest_id: i32,
        pub success: i32,
        pub submits: u32,
        pub ac_rate: f32,
        pub memory: i64,
        pub time: u64,
        pub difficulty: u32,
        pub public: bool,
        pub tags: String,
        pub title: String,
        pub content: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Model {
        #[inline]
        fn clone(&self) -> Model {
            Model {
                id: ::core::clone::Clone::clone(&self.id),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                contest_id: ::core::clone::Clone::clone(&self.contest_id),
                success: ::core::clone::Clone::clone(&self.success),
                submits: ::core::clone::Clone::clone(&self.submits),
                ac_rate: ::core::clone::Clone::clone(&self.ac_rate),
                memory: ::core::clone::Clone::clone(&self.memory),
                time: ::core::clone::Clone::clone(&self.time),
                difficulty: ::core::clone::Clone::clone(&self.difficulty),
                public: ::core::clone::Clone::clone(&self.public),
                tags: ::core::clone::Clone::clone(&self.tags),
                title: ::core::clone::Clone::clone(&self.title),
                content: ::core::clone::Clone::clone(&self.content),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Model {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "user_id",
                "contest_id",
                "success",
                "submits",
                "ac_rate",
                "memory",
                "time",
                "difficulty",
                "public",
                "tags",
                "title",
                "content",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.user_id,
                &self.contest_id,
                &self.success,
                &self.submits,
                &self.ac_rate,
                &self.memory,
                &self.time,
                &self.difficulty,
                &self.public,
                &self.tags,
                &self.title,
                &&self.content,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Model", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Model {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Model {
        #[inline]
        fn eq(&self, other: &Model) -> bool {
            self.id == other.id && self.user_id == other.user_id
                && self.contest_id == other.contest_id && self.success == other.success
                && self.submits == other.submits && self.ac_rate == other.ac_rate
                && self.memory == other.memory && self.time == other.time
                && self.difficulty == other.difficulty && self.public == other.public
                && self.tags == other.tags && self.title == other.title
                && self.content == other.content
        }
    }
    /// Generated by sea-orm-macros
    pub enum Column {
        /// Generated by sea-orm-macros
        Id,
        /// Generated by sea-orm-macros
        UserId,
        /// Generated by sea-orm-macros
        ContestId,
        /// Generated by sea-orm-macros
        Success,
        /// Generated by sea-orm-macros
        SubmitCount,
        /// Generated by sea-orm-macros
        AcRate,
        /// Generated by sea-orm-macros
        Memory,
        /// Generated by sea-orm-macros
        Time,
        /// Generated by sea-orm-macros
        Difficulty,
        /// Generated by sea-orm-macros
        Public,
        /// Generated by sea-orm-macros
        Tags,
        /// Generated by sea-orm-macros
        Title,
        /// Generated by sea-orm-macros
        Content,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Column {}
    #[automatically_derived]
    impl ::core::clone::Clone for Column {
        #[inline]
        fn clone(&self) -> Column {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Column {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Column::Id => "Id",
                    Column::UserId => "UserId",
                    Column::ContestId => "ContestId",
                    Column::Success => "Success",
                    Column::SubmitCount => "SubmitCount",
                    Column::AcRate => "AcRate",
                    Column::Memory => "Memory",
                    Column::Time => "Time",
                    Column::Difficulty => "Difficulty",
                    Column::Public => "Public",
                    Column::Tags => "Tags",
                    Column::Title => "Title",
                    Column::Content => "Content",
                },
            )
        }
    }
    ///An iterator over the variants of [Column]
    #[allow(missing_copy_implementations)]
    pub struct ColumnIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl core::fmt::Debug for ColumnIter {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("ColumnIter").field("len", &self.len()).finish()
        }
    }
    impl ColumnIter {
        fn get(&self, idx: usize) -> Option<Column> {
            match idx {
                0usize => ::core::option::Option::Some(Column::Id),
                1usize => ::core::option::Option::Some(Column::UserId),
                2usize => ::core::option::Option::Some(Column::ContestId),
                3usize => ::core::option::Option::Some(Column::Success),
                4usize => ::core::option::Option::Some(Column::SubmitCount),
                5usize => ::core::option::Option::Some(Column::AcRate),
                6usize => ::core::option::Option::Some(Column::Memory),
                7usize => ::core::option::Option::Some(Column::Time),
                8usize => ::core::option::Option::Some(Column::Difficulty),
                9usize => ::core::option::Option::Some(Column::Public),
                10usize => ::core::option::Option::Some(Column::Tags),
                11usize => ::core::option::Option::Some(Column::Title),
                12usize => ::core::option::Option::Some(Column::Content),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Column {
        type Iterator = ColumnIter;
        fn iter() -> ColumnIter {
            ColumnIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for ColumnIter {
        type Item = Column;
        fn next(&mut self) -> Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, Option<usize>) {
            let t = if self.idx + self.back_idx >= 13usize {
                0
            } else {
                13usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 13usize {
                self.idx = 13usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                self.get(idx - 1)
            }
        }
    }
    impl ExactSizeIterator for ColumnIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for ColumnIter {
        fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 13usize {
                self.back_idx = 13usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                self.get(13usize - self.back_idx)
            }
        }
    }
    impl Clone for ColumnIter {
        fn clone(&self) -> ColumnIter {
            ColumnIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl Column {
        fn default_as_str(&self) -> &str {
            match self {
                Self::Id => "id",
                Self::UserId => "user_id",
                Self::ContestId => "contest_id",
                Self::Success => "success",
                Self::SubmitCount => "submits",
                Self::AcRate => "ac_rate",
                Self::Memory => "memory",
                Self::Time => "time",
                Self::Difficulty => "difficulty",
                Self::Public => "public",
                Self::Tags => "tags",
                Self::Title => "title",
                Self::Content => "content",
            }
        }
    }
    #[automatically_derived]
    impl std::str::FromStr for Column {
        type Err = sea_orm::ColumnFromStrErr;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "id" | "id" => Ok(Column::Id),
                "user_id" | "userId" => Ok(Column::UserId),
                "contest_id" | "contestId" => Ok(Column::ContestId),
                "success" | "success" => Ok(Column::Success),
                "submits" | "submits" => Ok(Column::SubmitCount),
                "ac_rate" | "acRate" => Ok(Column::AcRate),
                "memory" | "memory" => Ok(Column::Memory),
                "time" | "time" => Ok(Column::Time),
                "difficulty" | "difficulty" => Ok(Column::Difficulty),
                "public" | "public" => Ok(Column::Public),
                "tags" | "tags" => Ok(Column::Tags),
                "title" | "title" => Ok(Column::Title),
                "content" | "content" => Ok(Column::Content),
                _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for Column {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Column {
        fn as_str(&self) -> &str {
            self.default_as_str()
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::ColumnTrait for Column {
        type EntityName = Entity;
        fn def(&self) -> sea_orm::prelude::ColumnDef {
            match self {
                Self::Id => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Integer,
                    )
                }
                Self::UserId => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Integer,
                    )
                }
                Self::ContestId => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Integer,
                    )
                }
                Self::Success => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Integer,
                    )
                }
                Self::SubmitCount => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Unsigned,
                    )
                }
                Self::AcRate => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Float,
                    )
                }
                Self::Memory => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::BigInteger,
                    )
                }
                Self::Time => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::BigUnsigned,
                    )
                }
                Self::Difficulty => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Unsigned,
                    )
                }
                Self::Public => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Boolean,
                    )
                }
                Self::Tags => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::String(None),
                    )
                }
                Self::Title => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::String(None),
                    )
                }
                Self::Content => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::String(None),
                    )
                }
            }
        }
        fn select_as(
            &self,
            expr: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
            }
        }
        fn save_as(
            &self,
            val: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct Entity;
    #[automatically_derived]
    impl ::core::marker::Copy for Entity {}
    #[automatically_derived]
    impl ::core::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Entity {
        #[inline]
        fn default() -> Entity {
            Entity {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Entity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Entity")
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::EntityTrait for Entity {
        type Model = Model;
        type Column = Column;
        type PrimaryKey = PrimaryKey;
        type Relation = Relation;
    }
    #[automatically_derived]
    impl sea_orm::Iden for Entity {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Entity {
        fn as_str(&self) -> &str {
            <Self as sea_orm::EntityName>::table_name(self)
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::EntityName for Entity {
        fn schema_name(&self) -> Option<&str> {
            None
        }
        fn table_name(&self) -> &str {
            "problem"
        }
    }
    /// Generated by sea-orm-macros
    pub enum PrimaryKey {
        /// Generated by sea-orm-macros
        Id,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PrimaryKey {}
    #[automatically_derived]
    impl ::core::clone::Clone for PrimaryKey {
        #[inline]
        fn clone(&self) -> PrimaryKey {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PrimaryKey {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Id")
        }
    }
    ///An iterator over the variants of [PrimaryKey]
    #[allow(missing_copy_implementations)]
    pub struct PrimaryKeyIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl core::fmt::Debug for PrimaryKeyIter {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
        }
    }
    impl PrimaryKeyIter {
        fn get(&self, idx: usize) -> Option<PrimaryKey> {
            match idx {
                0usize => ::core::option::Option::Some(PrimaryKey::Id),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
        type Iterator = PrimaryKeyIter;
        fn iter() -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for PrimaryKeyIter {
        type Item = PrimaryKey;
        fn next(&mut self) -> Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                self.get(idx - 1)
            }
        }
    }
    impl ExactSizeIterator for PrimaryKeyIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for PrimaryKeyIter {
        fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                self.get(1usize - self.back_idx)
            }
        }
    }
    impl Clone for PrimaryKeyIter {
        fn clone(&self) -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for PrimaryKey {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for PrimaryKey {
        fn as_str(&self) -> &str {
            match self {
                Self::Id => "id",
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
        type Column = Column;
        fn into_column(self) -> Self::Column {
            match self {
                Self::Id => Self::Column::Id,
            }
        }
        fn from_column(col: Self::Column) -> Option<Self> {
            match col {
                Self::Column::Id => Some(Self::Id),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl PrimaryKeyTrait for PrimaryKey {
        type ValueType = i32;
        fn auto_increment() -> bool {
            true
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for Model {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                            )
                            .into(),
                    )?,
                user_id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserId,
                            )
                            .into(),
                    )?,
                contest_id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::ContestId,
                            )
                            .into(),
                    )?,
                success: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Success,
                            )
                            .into(),
                    )?,
                submits: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::SubmitCount,
                            )
                            .into(),
                    )?,
                ac_rate: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::AcRate,
                            )
                            .into(),
                    )?,
                memory: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Memory,
                            )
                            .into(),
                    )?,
                time: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Time,
                            )
                            .into(),
                    )?,
                difficulty: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Difficulty,
                            )
                            .into(),
                    )?,
                public: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Public,
                            )
                            .into(),
                    )?,
                tags: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Tags,
                            )
                            .into(),
                    )?,
                title: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Title,
                            )
                            .into(),
                    )?,
                content: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Content,
                            )
                            .into(),
                    )?,
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::ModelTrait for Model {
        type Entity = Entity;
        fn get(
            &self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
        ) -> sea_orm::Value {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                    self.id.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserId => {
                    self.user_id.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::ContestId => {
                    self.contest_id.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Success => {
                    self.success.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubmitCount => {
                    self.submits.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::AcRate => {
                    self.ac_rate.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Memory => {
                    self.memory.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Time => {
                    self.time.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Difficulty => {
                    self.difficulty.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Public => {
                    self.public.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Tags => {
                    self.tags.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Title => {
                    self.title.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Content => {
                    self.content.clone().into()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    )
                }
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                    self.id = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserId => {
                    self.user_id = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::ContestId => {
                    self.contest_id = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Success => {
                    self.success = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubmitCount => {
                    self.submits = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::AcRate => {
                    self.ac_rate = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Memory => {
                    self.memory = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Time => {
                    self.time = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Difficulty => {
                    self.difficulty = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Public => {
                    self.public = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Tags => {
                    self.tags = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Title => {
                    self.title = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Content => {
                    self.content = v.unwrap();
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    )
                }
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct ActiveModel {
        /// Generated by sea-orm-macros
        pub id: sea_orm::ActiveValue<i32>,
        /// Generated by sea-orm-macros
        pub user_id: sea_orm::ActiveValue<i32>,
        /// Generated by sea-orm-macros
        pub contest_id: sea_orm::ActiveValue<i32>,
        /// Generated by sea-orm-macros
        pub success: sea_orm::ActiveValue<i32>,
        /// Generated by sea-orm-macros
        pub submits: sea_orm::ActiveValue<u32>,
        /// Generated by sea-orm-macros
        pub ac_rate: sea_orm::ActiveValue<f32>,
        /// Generated by sea-orm-macros
        pub memory: sea_orm::ActiveValue<i64>,
        /// Generated by sea-orm-macros
        pub time: sea_orm::ActiveValue<u64>,
        /// Generated by sea-orm-macros
        pub difficulty: sea_orm::ActiveValue<u32>,
        /// Generated by sea-orm-macros
        pub public: sea_orm::ActiveValue<bool>,
        /// Generated by sea-orm-macros
        pub tags: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub title: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub content: sea_orm::ActiveValue<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ActiveModel {
        #[inline]
        fn clone(&self) -> ActiveModel {
            ActiveModel {
                id: ::core::clone::Clone::clone(&self.id),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                contest_id: ::core::clone::Clone::clone(&self.contest_id),
                success: ::core::clone::Clone::clone(&self.success),
                submits: ::core::clone::Clone::clone(&self.submits),
                ac_rate: ::core::clone::Clone::clone(&self.ac_rate),
                memory: ::core::clone::Clone::clone(&self.memory),
                time: ::core::clone::Clone::clone(&self.time),
                difficulty: ::core::clone::Clone::clone(&self.difficulty),
                public: ::core::clone::Clone::clone(&self.public),
                tags: ::core::clone::Clone::clone(&self.tags),
                title: ::core::clone::Clone::clone(&self.title),
                content: ::core::clone::Clone::clone(&self.content),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ActiveModel {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "user_id",
                "contest_id",
                "success",
                "submits",
                "ac_rate",
                "memory",
                "time",
                "difficulty",
                "public",
                "tags",
                "title",
                "content",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.user_id,
                &self.contest_id,
                &self.success,
                &self.submits,
                &self.ac_rate,
                &self.memory,
                &self.time,
                &self.difficulty,
                &self.public,
                &self.tags,
                &self.title,
                &&self.content,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ActiveModel",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ActiveModel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ActiveModel {
        #[inline]
        fn eq(&self, other: &ActiveModel) -> bool {
            self.id == other.id && self.user_id == other.user_id
                && self.contest_id == other.contest_id && self.success == other.success
                && self.submits == other.submits && self.ac_rate == other.ac_rate
                && self.memory == other.memory && self.time == other.time
                && self.difficulty == other.difficulty && self.public == other.public
                && self.tags == other.tags && self.title == other.title
                && self.content == other.content
        }
    }
    #[automatically_derived]
    impl std::default::Default for ActiveModel {
        fn default() -> Self {
            <Self as sea_orm::ActiveModelBehavior>::new()
        }
    }
    #[automatically_derived]
    impl std::convert::From<<Entity as EntityTrait>::Model> for ActiveModel {
        fn from(m: <Entity as EntityTrait>::Model) -> Self {
            Self {
                id: sea_orm::ActiveValue::unchanged(m.id),
                user_id: sea_orm::ActiveValue::unchanged(m.user_id),
                contest_id: sea_orm::ActiveValue::unchanged(m.contest_id),
                success: sea_orm::ActiveValue::unchanged(m.success),
                submits: sea_orm::ActiveValue::unchanged(m.submits),
                ac_rate: sea_orm::ActiveValue::unchanged(m.ac_rate),
                memory: sea_orm::ActiveValue::unchanged(m.memory),
                time: sea_orm::ActiveValue::unchanged(m.time),
                difficulty: sea_orm::ActiveValue::unchanged(m.difficulty),
                public: sea_orm::ActiveValue::unchanged(m.public),
                tags: sea_orm::ActiveValue::unchanged(m.tags),
                title: sea_orm::ActiveValue::unchanged(m.title),
                content: sea_orm::ActiveValue::unchanged(m.content),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::IntoActiveModel<ActiveModel> for <Entity as EntityTrait>::Model {
        fn into_active_model(self) -> ActiveModel {
            self.into()
        }
    }
    #[automatically_derived]
    impl sea_orm::ActiveModelTrait for ActiveModel {
        type Entity = Entity;
        fn take(
            &mut self,
            c: <Self::Entity as EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as EntityTrait>::Column::Id => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.id);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::UserId => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.user_id);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::ContestId => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.contest_id);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Success => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.success);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::SubmitCount => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.submits);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::AcRate => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.ac_rate);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Memory => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.memory);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Time => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.time);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Difficulty => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.difficulty);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Public => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.public);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Tags => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.tags);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Title => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.title);
                    value.into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Content => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.content);
                    value.into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn get(
            &self,
            c: <Self::Entity as EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as EntityTrait>::Column::Id => {
                    self.id.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::UserId => {
                    self.user_id.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::ContestId => {
                    self.contest_id.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Success => {
                    self.success.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::SubmitCount => {
                    self.submits.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::AcRate => {
                    self.ac_rate.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Memory => {
                    self.memory.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Time => {
                    self.time.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Difficulty => {
                    self.difficulty.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Public => {
                    self.public.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Tags => {
                    self.tags.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Title => {
                    self.title.clone().into_wrapped_value()
                }
                <Self::Entity as EntityTrait>::Column::Content => {
                    self.content.clone().into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn set(&mut self, c: <Self::Entity as EntityTrait>::Column, v: sea_orm::Value) {
            match c {
                <Self::Entity as EntityTrait>::Column::Id => {
                    self.id = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::UserId => {
                    self.user_id = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::ContestId => {
                    self.contest_id = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Success => {
                    self.success = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::SubmitCount => {
                    self.submits = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::AcRate => {
                    self.ac_rate = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Memory => {
                    self.memory = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Time => {
                    self.time = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Difficulty => {
                    self.difficulty = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Public => {
                    self.public = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Tags => {
                    self.tags = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Title => {
                    self.title = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as EntityTrait>::Column::Content => {
                    self.content = sea_orm::ActiveValue::set(v.unwrap());
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    )
                }
            }
        }
        fn not_set(&mut self, c: <Self::Entity as EntityTrait>::Column) {
            match c {
                <Self::Entity as EntityTrait>::Column::Id => {
                    self.id = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::UserId => {
                    self.user_id = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::ContestId => {
                    self.contest_id = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Success => {
                    self.success = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::SubmitCount => {
                    self.submits = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::AcRate => {
                    self.ac_rate = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Memory => {
                    self.memory = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Time => {
                    self.time = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Difficulty => {
                    self.difficulty = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Public => {
                    self.public = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Tags => {
                    self.tags = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Title => {
                    self.title = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as EntityTrait>::Column::Content => {
                    self.content = sea_orm::ActiveValue::not_set();
                }
                _ => {}
            }
        }
        fn is_not_set(&self, c: <Self::Entity as EntityTrait>::Column) -> bool {
            match c {
                <Self::Entity as EntityTrait>::Column::Id => self.id.is_not_set(),
                <Self::Entity as EntityTrait>::Column::UserId => {
                    self.user_id.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::ContestId => {
                    self.contest_id.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::Success => {
                    self.success.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::SubmitCount => {
                    self.submits.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::AcRate => {
                    self.ac_rate.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::Memory => self.memory.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Time => self.time.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Difficulty => {
                    self.difficulty.is_not_set()
                }
                <Self::Entity as EntityTrait>::Column::Public => self.public.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Tags => self.tags.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Title => self.title.is_not_set(),
                <Self::Entity as EntityTrait>::Column::Content => {
                    self.content.is_not_set()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    )
                }
            }
        }
        fn default() -> Self {
            Self {
                id: sea_orm::ActiveValue::not_set(),
                user_id: sea_orm::ActiveValue::not_set(),
                contest_id: sea_orm::ActiveValue::not_set(),
                success: sea_orm::ActiveValue::not_set(),
                submits: sea_orm::ActiveValue::not_set(),
                ac_rate: sea_orm::ActiveValue::not_set(),
                memory: sea_orm::ActiveValue::not_set(),
                time: sea_orm::ActiveValue::not_set(),
                difficulty: sea_orm::ActiveValue::not_set(),
                public: sea_orm::ActiveValue::not_set(),
                tags: sea_orm::ActiveValue::not_set(),
                title: sea_orm::ActiveValue::not_set(),
                content: sea_orm::ActiveValue::not_set(),
            }
        }
        fn reset(&mut self, c: <Self::Entity as EntityTrait>::Column) {
            match c {
                <Self::Entity as EntityTrait>::Column::Id => self.id.reset(),
                <Self::Entity as EntityTrait>::Column::UserId => self.user_id.reset(),
                <Self::Entity as EntityTrait>::Column::ContestId => {
                    self.contest_id.reset()
                }
                <Self::Entity as EntityTrait>::Column::Success => self.success.reset(),
                <Self::Entity as EntityTrait>::Column::SubmitCount => self.submits.reset(),
                <Self::Entity as EntityTrait>::Column::AcRate => self.ac_rate.reset(),
                <Self::Entity as EntityTrait>::Column::Memory => self.memory.reset(),
                <Self::Entity as EntityTrait>::Column::Time => self.time.reset(),
                <Self::Entity as EntityTrait>::Column::Difficulty => {
                    self.difficulty.reset()
                }
                <Self::Entity as EntityTrait>::Column::Public => self.public.reset(),
                <Self::Entity as EntityTrait>::Column::Tags => self.tags.reset(),
                <Self::Entity as EntityTrait>::Column::Title => self.title.reset(),
                <Self::Entity as EntityTrait>::Column::Content => self.content.reset(),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl std::convert::TryFrom<ActiveModel> for <Entity as EntityTrait>::Model {
        type Error = sea_orm::DbErr;
        fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
            if match a.id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
            }
            if match a.user_id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("user_id".to_owned()));
            }
            if match a.contest_id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("contest_id".to_owned()));
            }
            if match a.success {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("success".to_owned()));
            }
            if match a.submits {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("submits".to_owned()));
            }
            if match a.ac_rate {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("ac_rate".to_owned()));
            }
            if match a.memory {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("memory".to_owned()));
            }
            if match a.time {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("time".to_owned()));
            }
            if match a.difficulty {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("difficulty".to_owned()));
            }
            if match a.public {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("public".to_owned()));
            }
            if match a.tags {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("tags".to_owned()));
            }
            if match a.title {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("title".to_owned()));
            }
            if match a.content {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("content".to_owned()));
            }
            Ok(Self {
                id: a.id.into_value().unwrap().unwrap(),
                user_id: a.user_id.into_value().unwrap().unwrap(),
                contest_id: a.contest_id.into_value().unwrap().unwrap(),
                success: a.success.into_value().unwrap().unwrap(),
                submits: a.submits.into_value().unwrap().unwrap(),
                ac_rate: a.ac_rate.into_value().unwrap().unwrap(),
                memory: a.memory.into_value().unwrap().unwrap(),
                time: a.time.into_value().unwrap().unwrap(),
                difficulty: a.difficulty.into_value().unwrap().unwrap(),
                public: a.public.into_value().unwrap().unwrap(),
                tags: a.tags.into_value().unwrap().unwrap(),
                title: a.title.into_value().unwrap().unwrap(),
                content: a.content.into_value().unwrap().unwrap(),
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::TryIntoModel<<Entity as EntityTrait>::Model> for ActiveModel {
        fn try_into_model(
            self,
        ) -> Result<<Entity as EntityTrait>::Model, sea_orm::DbErr> {
            self.try_into()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Model {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "user_id" => _serde::__private::Ok(__Field::__field1),
                            "contest_id" => _serde::__private::Ok(__Field::__field2),
                            "success" => _serde::__private::Ok(__Field::__field3),
                            "submits" => _serde::__private::Ok(__Field::__field4),
                            "ac_rate" => _serde::__private::Ok(__Field::__field5),
                            "memory" => _serde::__private::Ok(__Field::__field6),
                            "time" => _serde::__private::Ok(__Field::__field7),
                            "difficulty" => _serde::__private::Ok(__Field::__field8),
                            "public" => _serde::__private::Ok(__Field::__field9),
                            "tags" => _serde::__private::Ok(__Field::__field10),
                            "title" => _serde::__private::Ok(__Field::__field11),
                            "content" => _serde::__private::Ok(__Field::__field12),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"user_id" => _serde::__private::Ok(__Field::__field1),
                            b"contest_id" => _serde::__private::Ok(__Field::__field2),
                            b"success" => _serde::__private::Ok(__Field::__field3),
                            b"submits" => _serde::__private::Ok(__Field::__field4),
                            b"ac_rate" => _serde::__private::Ok(__Field::__field5),
                            b"memory" => _serde::__private::Ok(__Field::__field6),
                            b"time" => _serde::__private::Ok(__Field::__field7),
                            b"difficulty" => _serde::__private::Ok(__Field::__field8),
                            b"public" => _serde::__private::Ok(__Field::__field9),
                            b"tags" => _serde::__private::Ok(__Field::__field10),
                            b"title" => _serde::__private::Ok(__Field::__field11),
                            b"content" => _serde::__private::Ok(__Field::__field12),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Model>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Model;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Model",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            f32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct Model with 13 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Model {
                            id: __field0,
                            user_id: __field1,
                            contest_id: __field2,
                            success: __field3,
                            submits: __field4,
                            ac_rate: __field5,
                            memory: __field6,
                            time: __field7,
                            difficulty: __field8,
                            public: __field9,
                            tags: __field10,
                            title: __field11,
                            content: __field12,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<f32> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contest_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "success",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "submits",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ac_rate",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("memory"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("time"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "difficulty",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("user_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("contest_id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("success")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("submits")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ac_rate")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("memory")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("time")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("difficulty")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("public")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        _serde::__private::Ok(Model {
                            id: __field0,
                            user_id: __field1,
                            contest_id: __field2,
                            success: __field3,
                            submits: __field4,
                            ac_rate: __field5,
                            memory: __field6,
                            time: __field7,
                            difficulty: __field8,
                            public: __field9,
                            tags: __field10,
                            title: __field11,
                            content: __field12,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "user_id",
                    "contest_id",
                    "success",
                    "submits",
                    "ac_rate",
                    "memory",
                    "time",
                    "difficulty",
                    "public",
                    "tags",
                    "title",
                    "content",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Model",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Model>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Model {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Model",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_id",
                    &self.user_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contest_id",
                    &self.contest_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "success",
                    &self.success,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "submits",
                    &self.submits,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ac_rate",
                    &self.ac_rate,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memory",
                    &self.memory,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "time",
                    &self.time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "difficulty",
                    &self.difficulty,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "public",
                    &self.public,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    pub enum Relation {
        User,
        Contest,
        Submit,
        Education,
        TestCase,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Relation {}
    #[automatically_derived]
    impl ::core::clone::Clone for Relation {
        #[inline]
        fn clone(&self) -> Relation {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Relation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Relation::User => "User",
                    Relation::Contest => "Contest",
                    Relation::Submit => "Submit",
                    Relation::Education => "Education",
                    Relation::TestCase => "TestCase",
                },
            )
        }
    }
    ///An iterator over the variants of [Relation]
    #[allow(missing_copy_implementations)]
    pub struct RelationIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl core::fmt::Debug for RelationIter {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("RelationIter").field("len", &self.len()).finish()
        }
    }
    impl RelationIter {
        fn get(&self, idx: usize) -> Option<Relation> {
            match idx {
                0usize => ::core::option::Option::Some(Relation::User),
                1usize => ::core::option::Option::Some(Relation::Contest),
                2usize => ::core::option::Option::Some(Relation::Submit),
                3usize => ::core::option::Option::Some(Relation::Education),
                4usize => ::core::option::Option::Some(Relation::TestCase),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Relation {
        type Iterator = RelationIter;
        fn iter() -> RelationIter {
            RelationIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for RelationIter {
        type Item = Relation;
        fn next(&mut self) -> Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, Option<usize>) {
            let t = if self.idx + self.back_idx >= 5usize {
                0
            } else {
                5usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 5usize {
                self.idx = 5usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                self.get(idx - 1)
            }
        }
    }
    impl ExactSizeIterator for RelationIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for RelationIter {
        fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 5usize {
                self.back_idx = 5usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                self.get(5usize - self.back_idx)
            }
        }
    }
    impl Clone for RelationIter {
        fn clone(&self) -> RelationIter {
            RelationIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    impl RelationTrait for Relation {
        fn def(&self) -> RelationDef {
            match self {
                Self::User => {
                    Entity::belongs_to(user::Entity)
                        .from(Column::UserId)
                        .to(user::Column::Id)
                        .into()
                }
                Self::Contest => {
                    Entity::belongs_to(contest::Entity)
                        .from(Column::ContestId)
                        .to(contest::Column::Id)
                        .into()
                }
                Self::Submit => Entity::has_many(submit::Entity).into(),
                Self::Education => Entity::has_many(education::Entity).into(),
                Self::TestCase => Entity::has_many(testcase::Entity).into(),
            }
        }
    }
    impl Related<user::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::User.def()
        }
    }
    impl Related<contest::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Contest.def()
        }
    }
    impl Related<submit::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Submit.def()
        }
    }
    impl Related<education::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Submit.def()
        }
    }
    impl Related<testcase::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::TestCase.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
    type Problem = Entity;
    #[sea_orm(entity = "Problem")]
    struct PartialProblem {
        #[sea_orm(from_col = "id")]
        pub id: i32,
    }
    #[automatically_derived]
    impl sea_orm::PartialModelTrait for PartialProblem {
        fn select_cols<S: sea_orm::SelectColumns>(select: S) -> S {
            let select = sea_orm::SelectColumns::select_column_as(
                select,
                <Problem as sea_orm::EntityTrait>::Column::Id,
                "id",
            );
            select
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for PartialProblem {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                id: row.try_get(pre, "id")?,
            })
        }
    }
}
